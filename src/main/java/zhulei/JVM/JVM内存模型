方法区（Method Area）：
和java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量，以及编译器编译后的代码等数据。
方法区又称为“非堆”，为了跟java堆区别开来。
方法区还被很多人称为“永久代”，但其实二者并不等价，因为仅仅只有HotSpot虚拟机用永久代来实现方法区。
而永久代并不一定是永久存在，也需要对常量池的垃圾回收和对类的卸载，所以这里还是有垃圾回收的机制的。
java虚拟机规范对方法区的限制非常宽松，除了和java堆一样不需要连续的内存和可以选择固定大小和可扩展之外，还可以选择不实现垃圾回收。
（注：当然现在也有去永久代的做法，具体从JDK1.7开始，然后1.8实行，有兴趣可以去了解）

堆（Heap）：
堆内存主要存放对象和数组，几乎所有的对象实例，都是在这里被创建，是JVM管理内存中最大和最主要的一块区域。
堆内存和方法区都被所有线程共享，在虚拟机启动时被创建。
相对于方法区的永久代，堆内存还可细分为新生代和永久代（分代收集算法）

程序计数器（Program Counter Register）
Java虚拟机多线程是通过线程轮流切换并分配处理器的执行时间的方式来实现的，而每个线程都有一个独立的程序计数器。
所以任何一个确定的时刻，一个处理器都只会执行一条线程中的指令，相互独立。
字节码解释器工作就是通过改变这个计数器的值来选择下一条需要执行的字节码指令。
分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

虚拟机栈（VM Stack）
虚拟机栈同程序计数器一样，也是每个线程私有的一块内存空间，它描述的是方法的内存模型。虚拟机会为每个线程分配一个虚拟机栈。
每个虚拟机栈中都有若干个栈帧，每个栈帧中存储了局部变量表、操作数栈、动态链接、返回地址等。
一个栈帧就对应Java代码中的一个方法，当线程执行到一个方法时，就代表这个方法对应的栈帧已经进入虚拟机栈并且处于栈顶的位置，
每一个Java方法从被调用到执行结束，就对应了一个栈帧从入栈到出栈的过程。

本地方法栈（Native Method Stack）
本地方法栈与虚拟机栈的区别是，虚拟机栈执行的是Java方法，本地方法栈执行的是本地方法，其他基本上一致。
在HotSpot中直接把本地方法栈和虚拟机栈合二为一。